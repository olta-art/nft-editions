{
  "address": "0x26a7811cd374AE3140d302F64567Af2E3c18106e",
  "abi": [],
  "transactionHash": "0xbe03ee9e03bfca5e38ee408d74969ad41698e8530085c37e23e95797d3781fff",
  "receipt": {
    "to": null,
    "from": "0x5712869b7C8ca52B00Af7F6D924D4C841781ccd4",
    "contractAddress": "0x26a7811cd374AE3140d302F64567Af2E3c18106e",
    "transactionIndex": 10,
    "gasUsed": "72217",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000008000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080004000000000000100000000000000000000008000000000040000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x08e72c3a5a1e1a13ed316b3682506f8110f4d7b779b1611eb75778209f85588b",
    "transactionHash": "0xbe03ee9e03bfca5e38ee408d74969ad41698e8530085c37e23e95797d3781fff",
    "logs": [
      {
        "transactionIndex": 10,
        "blockNumber": 30941612,
        "transactionHash": "0xbe03ee9e03bfca5e38ee408d74969ad41698e8530085c37e23e95797d3781fff",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000005712869b7c8ca52b00af7f6d924d4c841781ccd4",
          "0x00000000000000000000000000856730088a5c3191bd26eb482e45229555ce57"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000133646a1a4451f00000000000000000000000000000000000000000000001f88b48e260679b3b000000000000000000000000000000000000000000000039f7e39c3bb2bba77de00000000000000000000000000000000000000000000001f88a157df64d56e9100000000000000000000000000000000000000000000039f7e4cfa01cd5ebcfd",
        "logIndex": 52,
        "blockHash": "0x08e72c3a5a1e1a13ed316b3682506f8110f4d7b779b1611eb75778209f85588b"
      }
    ],
    "blockNumber": 30941612,
    "cumulativeGasUsed": "2353310",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "f1085c5b85cb82252ad324af67a4fa4d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"author\":\"george baldwin\",\"details\":\"Provides versioning for nft content and follows the semantic labeling convention. Each version contains an array of content and content hash pairs as well as a version label. Versions can be added and urls can be updated along with getters to retrieve specific versions and history. Include with `using Versions for Versions.set;`\",\"kind\":\"dev\",\"methods\":{},\"title\":\"A libary for versioning of NFT content and metadata\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Versions.sol\":\"Versions\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0xc7af08df3d3e818ce36f95aa879c13245772fed21b553e6033292ea4edc2a9f3\",\"license\":\"MIT\"},\"contracts/Versions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport {StringsUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\n\\n/**\\n @title A libary for versioning of NFT content and metadata\\n @dev Provides versioning for nft content and follows the semantic labeling convention.\\n Each version contains an array of content and content hash pairs as well as a version label.\\n Versions can be added and urls can be updated along with getters to retrieve specific versions and history.\\n\\n Include with `using Versions for Versions.set;`\\n @author george baldwin\\n */\\n\\nlibrary Versions {\\n\\n    struct UrlHashPair {\\n        string url;\\n        bytes32 sha256hash;\\n    }\\n\\n    struct Version {\\n        UrlHashPair[] urls;\\n        uint8[3] label;\\n    }\\n\\n    struct Set {\\n        string[] labels;\\n        mapping(string => Version) versions;\\n    }\\n\\n    /**\\n     @dev creates a new version from array of url hashe pairs and a semantic label\\n     @param urls An array of urls with sha-256 hash of the content on that url\\n     @param label a version label in a semantic style\\n     */\\n    function createVersion(\\n        UrlHashPair[] memory urls,\\n        uint8[3] memory label\\n    )\\n        internal\\n        pure\\n        returns (Version memory)\\n    {\\n        Version memory version = Version(urls, label);\\n        return version;\\n    }\\n\\n    /**\\n     @dev adds a version to a given set by pushing the version label to an array\\n        and mapping the version to a string of that label. Will revert if the label already exists.\\n     @param set the set to add the version to\\n     @param version the version that will be stored\\n     */\\n    function addVersion(\\n        Set storage set,\\n        Version memory version\\n    ) internal {\\n\\n        string memory labelKey = uintArray3ToString(version.label);\\n\\n        require(\\n            set.versions[labelKey].urls.length == 0,\\n            \\\"#Versions: A version with that label already exists\\\"\\n        );\\n\\n        // add to labels array\\n        set.labels.push(labelKey);\\n\\n        // store urls and hashes in mapping\\n        for (uint256 i = 0; i < version.urls.length; i++){\\n            set.versions[labelKey].urls.push(version.urls[i]);\\n        }\\n\\n        // store label\\n        set.versions[labelKey].label = version.label;\\n    }\\n\\n    /**\\n     @dev gets a version from a given set. Will revert if the version doesn't exist.\\n     @param set The set to get the version from\\n     @param label The label of the requested version\\n     @return version The version corrosponeding to the label\\n     */\\n    function getVersion(\\n        Set storage set,\\n        uint8[3] memory label\\n    )\\n        internal\\n        view\\n        returns (Version memory)\\n    {\\n        Version memory version = set.versions[uintArray3ToString(label)];\\n        require(\\n            version.urls.length != 0,\\n            \\\"#Versions: The version does not exist\\\"\\n        );\\n        return version;\\n    }\\n\\n    /**\\n     @dev updates a url of a given version in a given set\\n     @param set The set containing the version of which the url will be updated\\n     @param label The label of the requested version\\n     @param index The index of the url\\n     @param newUrl The new url to be updated to\\n     */\\n    function updateVersionURL(\\n        Set storage set,\\n        uint8[3] memory label,\\n        uint256 index,\\n        string memory newUrl\\n    ) internal {\\n        string memory labelKey = uintArray3ToString(label);\\n        require(\\n            set.versions[labelKey].urls.length != 0,\\n            \\\"#Versions: The version does not exist\\\"\\n        );\\n        require(\\n            set.versions[labelKey].urls.length > index,\\n            \\\"#Versions: The url does not exist on that version\\\"\\n        );\\n        set.versions[labelKey].urls[index].url = newUrl;\\n    }\\n\\n    /**\\n     @dev gets all the version labels of a given set\\n     @param set The set containing the versions\\n     @return labels an array of labels as strings\\n    */\\n    function getAllLabels(\\n        Set storage set\\n    )\\n        internal\\n        view\\n        returns (string[] memory)\\n    {\\n        return set.labels;\\n    }\\n\\n    /**\\n     @dev gets all the versions of a given set\\n     @param set The set containing the versions\\n     @return versions an array of versions\\n    */\\n    function getAllVersions(\\n        Set storage set\\n    )\\n        internal\\n        view\\n        returns (Version[] memory)\\n    {\\n        return getVersionsFromLabels(set, set.labels);\\n    }\\n\\n    /**\\n     @dev gets the versions of a given array of labels as strings, reverts if no labels are given\\n     @param set The set containing the versions\\n     @return versions an array of versions\\n    */\\n    function getVersionsFromLabels(\\n        Set storage set,\\n        string[] memory _labels\\n    )\\n        internal\\n        view\\n        returns (Version[] memory)\\n    {\\n        require(_labels.length != 0, \\\"#Versions: No labels provided\\\");\\n        Version[] memory versionArray = new Version[](_labels.length);\\n\\n        for (uint256 i = 0; i < _labels.length; i++) {\\n                versionArray[i] = set.versions[_labels[i]];\\n        }\\n\\n        return versionArray;\\n    }\\n\\n    /**\\n     @dev gets the last added version of a given set, reverts if no versions are in the set\\n     @param set The set containing the versions\\n     @return version the last added version\\n    */\\n    function getLatestVersion(\\n        Set storage set\\n    )\\n        internal\\n        view\\n        returns (Version memory)\\n    {\\n        require(\\n            set.labels.length != 0,\\n            \\\"#Versions: No versions exist\\\"\\n        );\\n        return set.versions[\\n            set.labels[set.labels.length - 1]\\n        ];\\n    }\\n\\n    /**\\n     @dev A helper function to convert a three length array of numbers into a semantic style verison label\\n     @param label the label as a uint8[3] array\\n     @return label the label as a string\\n    */\\n    function uintArray3ToString (uint8[3] memory label)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(\\n            StringsUpgradeable.toString(label[0]),\\n            \\\".\\\",\\n            StringsUpgradeable.toString(label[1]),\\n            \\\".\\\",\\n            StringsUpgradeable.toString(label[2])\\n        ));\\n    }\\n}\",\"keccak256\":\"0x0c57f7a1764998753c382556ffee075a74875dc39460cb3bed3842bf5fbb9012\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122074892c2e30312fdb7282d94702fd6380243c674ba1ff200ff4ec34bb335a7a8a64736f6c63430008060033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122074892c2e30312fdb7282d94702fd6380243c674ba1ff200ff4ec34bb335a7a8a64736f6c63430008060033",
  "devdoc": {
    "author": "george baldwin",
    "details": "Provides versioning for nft content and follows the semantic labeling convention. Each version contains an array of content and content hash pairs as well as a version label. Versions can be added and urls can be updated along with getters to retrieve specific versions and history. Include with `using Versions for Versions.set;`",
    "kind": "dev",
    "methods": {},
    "title": "A libary for versioning of NFT content and metadata",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}